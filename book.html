<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Libre+Baskerville:ital,wght@0,400,700;1,400&display=swap');
    </style>
</head>
<body>
<svg version="1.1" id="pg" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 217.67 217.67" style="display:none;" xml:space="preserve">
        <path id="logo-p" d="M96.12,34.69c-10.45-6.27-24.27-3.43-33.91,0.29c-9.64,3.72-12.19,5.75-16.55,6.62c-4.36,0.87-5.46,0-5.69-2.03
        	c0.35-0.12,2.32-0.64,1.97-2.32c-0.35-1.68-1.63-2.73-5.57-1.97c-3.95,0.75-6.39,6.16-3.31,9.99c3.08,3.83,6.14,4.36,13.75,3.14
        	c0,0-0.04,42.27-0.04,53.47c0,0,0.24,14.66,0.06,24.79c-0.04,2.51-0.21,4.73-0.46,6.39c-0.59,3.85-1.22,6.16-3.89,7.32
        	c-1.81,0.79-4.47-0.46-3.89-2.56c0.58-2.09-0.29-2.73-1.51-2.84c-1.22-0.12-4.24,1.51-4.3,5.69c0,0-0.48,4.52,5.11,6.36
        	c5.59,1.84,10.48-0.69,13.95-4.9c4.25-5.15,6.64-11.17,7.01-21.16c0.01-0.15,0.01-0.15,0.01-0.13c0-0.11-0.01-0.73-0.01-3.59
        	c0-16.36,0-47.68,0-47.68s-0.14-15.15,0.21-18.41s4.81-11.33,15.93-13.24s21.95,5.81,24.5,21.95s-2.12,33.49-8.99,40.64
        	c-6.87,7.15-11.19,7.5-16.21,6.37c-5.03-1.13-4.53-6.23-3.75-7.79c0.78-1.56,5.1-1.49,3.19-4.25s-8.71-3.61-11.68,0.64
        	c-2.97,4.25-3.82,8.78,1.77,14.51c5.59,5.73,15.93,4.74,24.71,0.7s21.17-16.56,24.71-37.03C116.75,53.22,106.57,40.97,96.12,34.69z"/>
    <path id="logo-g" d="M186.74,86.33c-2.57-2.22-6.3-2.24-8.66-1.14c-2.36,1.11-4.23,2.94-4.55,4.78c-0.32,1.84,0.93,2.54,3.32,2.07
        	s3.21,0.9,2.74,2.65c-0.47,1.75-2.71,2.26-6.06,1.57c-3.36-0.68-8.94-3.75-19.15-4.53s-19-0.1-31.69,10.05
        	c-12.68,10.15-17.6,29.76-15.33,44.49c2.27,14.73,7.96,23.98,18.67,32.88c10.71,8.9,25.37,11.31,37.77,9.35
        	c11.78-1.87,19.96-4.93,21.87-6.91s-0.62-3.5-2.11-5.56c-1.49-2.06-2.76-4.2-2.76-9.45c0-4.46,0-22.62,0-27.23s1.81-5.7,4.04-8.32
        	c0.99-1.16,1.61-2.38,0.54-3.28c-1.34-1.14-3.18-0.17-5.31,0.8c-3.81,1.75-6.73,2.11-13.24,0.85s-9.94-4.25-16.99-4.14
        	c-5.73,0.08-10.33,2.87-12.36,6.74c-2.03,3.87-1.84,9.62,1.52,12.59c3.36,2.97,7.31,1.54,9.26-0.33s1.64-3.99,1.18-6.18
        	c-0.6-2.87-2.44-1.25-4.33-0.12c-0.85,0.51-2.03,0.27-2.38-0.62c-0.43-1.08-0.28-2.48,0.64-3.04c3.16-1.93,7.03,0.35,10.14,1.96
        	c3.12,1.6,5.85,4.25,15.29,1.13c0,0,0,28.53,0,30.61c0,1.09,0.03,3.51,0.75,5.96c0.46,1.55,1.29,3.28,2.11,4.15
        	c0.35,0.37,0.98,1.07-0.16,1.47c-1.14,0.4-14.58,5.49-26.09,0.32c-21.2-9.52-25.68-31.24-26.14-39.28
        	c-0.46-8.04,1.01-19.05,5.05-25.15c4.72-7.13,8.89-12.87,17.46-15.86c8.58-2.99,12.92-1.43,20.82,0.79s11.63,4.14,18.08,3
        	c6.44-1.14,9.01-4.96,9.36-8.98C190.42,90.42,189.31,88.55,186.74,86.33z"/>
    </svg>

</body>
<!--<script async="" src="https://unpkg.com/es-module-shims@0.13.1/dist/es-module-shims.js"></script>-->

<script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.7/dat.gui.min.js"></script>
<script type="importmap">
    {
        "imports": {
        "three": "https://unpkg.com/three@0.133.0/build/three.module.js"
    }
    }
</script>

<script type="module">


    import * as THREE from "three";
    import { HDRCubeTextureLoader } from "https://unpkg.com/three@0.133.0/examples/jsm/loaders/HDRCubeTextureLoader.js";
    import { RGBELoader } from 'https://unpkg.com/three@0.133.0/examples/jsm/loaders/RGBELoader.js';
    import { OrbitControls } from "https://unpkg.com/three@0.133.0/examples/jsm/controls/OrbitControls.js";
    import { USDZExporter } from "https://unpkg.com/three@0.133.0/examples/jsm/exporters/USDZExporter.js";
    import { GLTFExporter } from "https://unpkg.com/three@0.133.0/examples/jsm/exporters/GLTFExporter.js";
    import { Geometry } from "https://unpkg.com/three@0.133.0/examples/jsm/deprecated/Geometry.js";

    import { VRButton } from "https://unpkg.com/three@0.133.0/examples/jsm/webxr/VRButton.js";
    import { XRControllerModelFactory } from "https://unpkg.com/three@0.133.0/examples/jsm/webxr/XRControllerModelFactory.js";
    import { XRHandModelFactory } from "https://unpkg.com/three@0.133.0/examples/jsm/webxr/XRHandModelFactory.js";


    window.addEventListener("error", e => {
        alert("Error!\n" + e.name + ":\n" + e.message);
    });

    const smoothstep = (low, high, f) => {
        f = (f - low) / (high - low);
        f = Math.max(0, Math.min(1, f));
        return f * f * (3 - 2 * f);
    };

    class App {
        constructor()
        {
            this.loadedFilename = "Who Stole the Harlem of the West?";   // used as the title in the cover
            this.author = "Digitized by Sage Vousé";
            this.textNumber = "001";  // or any string you’d like
            this.language = "";
            this.releaseDate = "2024";


            this.filename = "Dummy";
            this.camera = new THREE.PerspectiveCamera(45, innerWidth / (innerHeight), .01, 20);
            this.camera.position.set(-0.24, 1.34, 0.51);
            this.initRenderer();


            this.controls = new OrbitControls(this.camera, this.renderer.domElement);
            this.controls.enableDamping = true;
            this.controls.target = new THREE.Vector3(0.02, 1.01, 0.51);

            this.scene = new THREE.Scene();
            // this.scene.add(new THREE.GridHelper(10,10));

            setTimeout(() => {
                this.initHDR();
            }, 500);

            this.initVR();

            this.pagePivot = new THREE.Object3D();
            this.scene.add(this.pagePivot);
            this.pagePivot.scale.setScalar(0.00125);
            this.pagePivot.position.y = 1.058;
            this.pagePivot.position.z = 0.46;


            //this.gui = new dat.GUI();
            this.options = {
                earlyPivot: 2.6,
                latePivot: 17,
                earlyThreshold: 4.5,
                lateThreshold: 12.3,
                earlyIntensity: 8.4,
                lateIntensity: 0.83,
                bookHeight: 18,
                bookWidth: 12,
                curlPivot: 11,
                curlThreshold: 12,
                turnCurveIntensity: 1.4,

            };

            this.pngFiles = [
                '1.png',
                '1-1.png',
                '2.png',
                '2-1.png',
                '3.png',
                '3-1.png',
                '4.png',
                '4-1.png',
                '5.png',
                '5-1.png',
                '6.png',
                '6-1.png',
                '7.png',
                '7-1.png',
                '8.png',
                '8-1.png',
                '9.png',
                '9-1.png',
                '10.png',
                '10-1.png',
                '11.png',
                '11-1.png',
                '12.png',
                '12-1.png',
            ];
            this.pageTextures = [];

            const loader = new THREE.TextureLoader();
            this.pngFiles.forEach((file, i) => {
                loader.load(
                    '../auf-zine-pngs/' + file,
                    (texture) => {
                        texture.minFilter = THREE.LinearFilter;
                        this.pageTextures[i] = texture;
                    },
                    undefined,
                    (error) => {
                        console.error('Error loading PNG file:', error);
                    }
                );
            });


            //so the lines per page at 180 was 32.
            //at 100 it was 18. 

           /* var curlParams = this.gui.addFolder("curl parameters");
            for (var prop in this.options) {
                curlParams.add(this.options, prop, 0, 20);
            }*/


            Object.assign(this.options, {
                openness: 1,
                linesPerPage: 32,
                turnSpeed: 0.1,
                pageCount: 22,
                autoAdvance: false,
                coverColor: "#fffff",
                typeColor: "black"
            });

           /* this.gui.add(this.options, "openness", 0.00, 1.0).listen();
            this.gui.add(this.options, "turnSpeed", -1, 1).listen();
            this.gui.add(this.options, "autoAdvance");



            this.gui.add(this, "loadText");*/

            this.options.exportModel = () => {
                window.glViewer.exportBook();
            }

            var isPhysical = true;
            //this.gui.add(this.options, "exportModel");
            window.glViewer = this;


            this.buildPages(0.01);

            this.turnAmount = 0;
            this.curPage = 0;
            this.prevPage = -1;
            this.centerCurve = 0;
            this.centerTurnCurve = 0;

            const ticker = new THREE.Mesh(new THREE.PlaneGeometry(0.001, 0.001), new THREE.MeshBasicMaterial({
                color: 'pink'
            }));
            this.scene.add(ticker);
            ticker.position.y = 1;
            ticker.position.z = 0.5;
            ticker.onBeforeRender = () => {

                if (!this.options.autoAdvance) {
                    this.options.turnSpeed = this.pageTurnImpulse || 0;
                }

                this.pageTurnImpulse *= 0.95;
                this.turnAmount += (this.options.turnSpeed) / 6 * smoothstep(0.1, 0.2, this.options.openness);
                this.turnAmount = Math.max(0.0, this.turnAmount);
                this.turnAmount = Math.min(this.options.pageCount, this.turnAmount);
                this.curPage = Math.floor(this.turnAmount / 2) * 2;

                this.centerCurve = this.center.curve = 1 - this.turnAmount % 2;
                this.centerTurnCurve = this.center.turnCurve = 2 * smoothstep(1, 0.0, Math.abs(this.center.curve)) * Math.sign(-this.options.turnSpeed);

                if (this.curPage != this.prevPage) {

                    requestAnimationFrame(() => {
                        if (this.curPage % 1 == 0) {
                            this.buildPages(this.curPage / this.options.pageCount + 0.01);
                        }
                        this.setPagesFrom(this.curPage, Math.sign(this.center.curve), this.left, this.center, this.right);
                    });
                    this.prevPage = this.curPage;
                }

                this.options.spineCurveIntensity = (this.turnAmount - this.options.pageCount / 2) / this.options.pageCount / 2 * 0.7;
                this.pagePivot.rotation.x = this.pagePivot.rotation.x * 0.9 + 0.1 * ((-this.options.spineCurveIntensity * Math.PI * 1.3) * this.options.openness + (1 - this.options.openness) * Math.PI / 2);
            }
            this.initClickPivots();


        }
        // this.addShelf();



        onPointerMove(event)
        {
            this.pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
            this.pointer.y = -(event.clientY / window.innerHeight) * 2 + 1;
        }

        updatePointer()
        {
            this.raycaster.setFromCamera(this.pointer, this.camera);


            if (this.pointerDown) {

                var intersects = this.raycaster.intersectObjects([this.bottomDragPlane], false);
                if (intersects.length > 0) {
                    this.hitPoint = intersects[0].point;
                    this.clickDot.position.copy(this.hitPoint);

                    //let's get that angle! It's in X and Y I think.
                    var angle = Math.atan2(this.hitPoint.z - 0.46, this.hitPoint.y - 1.058);
                    this.clickDot.position.z = 0.14 * Math.sin(angle) + 0.46;
                    this.clickDot.position.y = 0.14 * Math.cos(angle) + 1.058;
                    this.dotScreen = this.clickDot.position.clone().project(this.camera);

                    this.options.openness = 0.9 * this.options.openness + 0.1 * smoothstep(90, -90, angle * 57);
                }

            } else {


                var intersects = this.raycaster.intersectObjects([this.bottomClickPivot, this.left, this.right], false);
                if (intersects.length > 0) {
                    var hit = intersects[0].object
                    if (hit == this.bottomClickPivot) {
                        this.hoverTarget = this.bottomClickPivot;

                    } else if (hit == this.left) {
                        this.hoverTarget = this.left;
                        this.left.rightPage.emissive = new THREE.Color(1, 1, 0.5);
                        this.right.leftPage.emissive = new THREE.Color(0, 0, 0);
                    } else if (hit == this.right) {
                        this.right.leftPage.emissive = new THREE.Color(1, 1, 0.5);
                        this.left.rightPage.emissive = new THREE.Color(0, 0, 0);
                        this.hoverTarget = this.right;
                    }
                } else {
                    this.left.rightPage.emissive = new THREE.Color(0, 0, 0);
                    this.right.leftPage.emissive = new THREE.Color(0, 0, 0);
                    this.hoverTarget = null;
                }
            }
        }

        onPointerDown(event)
        {
            if (this.hoverTarget != null) {
                if (this.hoverTarget == this.left) {
                    this.pageTurnImpulse -= 0.5;
                    return;
                }
                if (this.hoverTarget == this.right) {
                    this.pageTurnImpulse += 0.5;
                    return;
                }

                this.pointerDown = true;
                this.controls.saveState();
                this.controls.enabled = false;
            } else {
                if (!this.controls.enabled) {
                    this.controls.enabled = true;
                    this.controls.reset();
                }
            }
        }

        initClickPivots()
        {
            this.raycaster = new THREE.Raycaster();
            this.pointer = new THREE.Vector2();
            this.clickDot = new THREE.Mesh(new THREE.SphereGeometry(0.000003, 12, 12), new THREE.MeshBasicMaterial({
                color: 'red'
            }));
            this.scene.add(this.clickDot);
            this.pageTurnImpulse = 0;
            this.dotScreen = new THREE.Vector3();
            document.addEventListener('pointermove', e => this.onPointerMove(e));
            document.addEventListener('pointerdown', e => this.onPointerDown(e));
            document.addEventListener('pointerup', e => {
                this.pointerDown = false;
            });
            this.hoverTarget = null;
            this.pointerDown = false;



        }

        processFile(loadEvent)
        {
            this.text = loadEvent.target.result.split("\n");
            this.options.linesPerPage = (this.options.bookHeight - 1) * 1.92;
            this.options.pageCount = Math.ceil(this.text.length / this.options.linesPerPage / 2) * 2;
            //let's get the title!

            this.title = null;
            this.author = null;
            this.textNumber = null;


            for (var n = 0; n < 50; n++) {
                var splitter = this.text[n].split("itle: ");
                if (splitter.length > 1) {
                    this.title = splitter[1];
                }

                splitter = this.text[n].split("anguage: ");
                if (splitter.length > 1) {
                    this.language = splitter[1];
                }

                splitter = this.text[n].split("uthor: ");
                if (splitter.length > 1) {
                    this.author = splitter[1];
                }

                splitter = this.text[n].toLowerCase().split("elease date: ");
                if (splitter.length > 1) {
                    this.releaseDate = splitter[1].split("[")[0];
                }

                splitter = this.text[n].replace(/[\[\]]/g, "").toLowerCase().split(/ebook #|etext #/);
                if (splitter.length > 1) {
                    this.textNumber = splitter[splitter.length - 1];
                }

            }
            this.loadedFilename = this.title;
        }




        loadText()
        {
            const input = document.createElement('input');
            input.type = "file";
            var filename;
            input.addEventListener('change', changeEvent => {
                var fR = new FileReader();
                fR.addEventListener('load', loadEvent => this.processFile(loadEvent));
                // debugger;
                filename = changeEvent.target.files[0].name;
                fR.readAsText(changeEvent.target.files[0]);
            });

            input.click();



        }

        drawBorder(g, aspect)
        {
            var borderString = new Path2D("M121.05,116.02c0,0,0-23.72,0-41.47s0-44.96,0-44.96H34.62M93.05,86.02c0,0,93.59,0,103.98,0s91.8,0,91.8,0V30.15h259.52M0,0.5h97.36v64.66c0,0,29.26,0,41.39,0c12.12,0,35.89,0,35.89,0V0.5h566.22");
            var margin = 40;
            var scale = 0.55;

            g.save();
            g.scale(scale, scale);
            g.save();
            g.translate(margin, margin);
            g.stroke(borderString);
            g.restore();

            g.save();
            g.translate(margin, margin);
            g.rotate(Math.PI / 2);
            g.scale(1, -1);
            g.stroke(borderString);
            g.restore();


            g.save();
            g.translate(1024 / scale - margin, margin);
            g.scale(-1, 1);
            g.stroke(borderString);
            g.restore();

            g.save();
            g.translate(1024 / scale - margin, margin);
            g.rotate(-Math.PI / 2);
            g.scale(-1, -1);
            g.stroke(borderString);
            g.restore();

            g.translate(0, 1024 / scale / aspect);
            g.scale(1, -1);
            g.save();
            g.translate(margin, margin);
            g.stroke(borderString);
            g.restore();

            g.save();
            g.translate(margin, margin);
            g.rotate(Math.PI / 2);
            g.scale(1, -1);
            g.stroke(borderString);
            g.restore();


            g.save();
            g.translate(1024 / scale - margin, margin);
            g.scale(-1, 1);
            g.stroke(borderString);
            g.restore();

            g.save();
            g.translate(1024 / scale - margin, margin);
            g.rotate(-Math.PI / 2);
            g.scale(-1, -1);
            g.stroke(borderString);
            g.restore();



            g.restore();
        }

        stampLogo(g, aspect)
        {
            var logoP = new Path2D(document.querySelector("#logo-p").getAttribute('d'));
            var logoG = new Path2D(document.querySelector("#logo-g").getAttribute('d'));
            g.save();

            g.font = "30px Libre Baskerville";
            g.fillText("A", 340, 55);
            g.fillText("Imprint", 599, 55);
            g.font = "italic 30px Libre Baskerville";
            g.fillText("Project Gutenberg", 370, 55);
            g.font = "40px Libre Baskerville";
            var w = g.measureText("#" + this.textNumber).width;
            g.fillText("#" + this.textNumber, 512 - w / 2, 275);
            g.font = "30px Libre Baskerville";
            var w = g.measureText(this.language).width;
            g.fillText(this.language, 512 - w / 2, 1024 / aspect - 15);
            g.translate(512 - 220 / 2, 55);
            g.fill(logoP);
            g.fill(logoG);
            g.restore();




        }
        coverPage()
        {

            if (window.cover == null || this.filename != this.loadedFilename) {
                this.filename = this.loadedFilename;
                const c = document.createElement('canvas');
                c.width = c.height = 1024;
                var aspect = this.options.bookWidth / this.options.bookHeight;
                const g = c.getContext('2d');

                var gold = this.options.typeColor;
                g.fillStyle = this.options.coverColor;
                g.fillRect(0, 0, 1024, 1024);

                const ormC = document.createElement('canvas');
                ormC.width = ormC.height = 1024;
                const ormG = ormC.getContext('2d');
                ormG.fillStyle = "rgb(0,80,0)";

                ormG.fillRect(0, 0, 1024, 1024);

                for (var i = 0; i < 20; i++) {
                    var rx = Math.random() * 1024;
                    var ry = Math.random() * 1024;
                    const radialGrad = ormG.createRadialGradient(rx, ry, 0, rx, ry, 400 + Math.random() * 100);
                    const rough = Math.floor(32 + Math.random() * (255 - 32));
                    radialGrad.addColorStop(0, `rgba(0,${rough},0,0.25)`);
                    radialGrad.addColorStop(1, `rgba(0,${rough},0,0)`);
                    ormG.fillStyle = radialGrad;
                    ormG.fillRect(0, 0, 1024, 1024);

                }


                const bumpC = document.createElement('canvas');
                bumpC.width = bumpC.height = 1024;
                const bumpG = bumpC.getContext('2d');
                bumpG.fillStyle = "gray";
                bumpG.fillRect(0, 0, 1024, 1024);

                g.scale(1, aspect);
                ormG.scale(1, aspect);
                bumpG.scale(1, aspect);


                g.fillStyle = gold;
                g.font = "700 80px Libre Baskerville";





                g.strokeStyle = gold;
                g.lineWidth = "8";
                g.lineJoin = "round";
                g.lineCap = "square";

                this.drawBorder(g, aspect);

                ormG.lineWidth = "8";
                ormG.lineJoin = "round";
                ormG.lineCap = "square";
                ormG.strokeStyle = "rgb(0, 30,255)";

                bumpG.lineWidth = "8";
                bumpG.lineJoin = "round";
                bumpG.lineCap = "square";
                bumpG.strokeStyle = "rgb(255, 30,255)";

                this.drawBorder(ormG, aspect);
                this.drawBorder(bumpG, aspect);

                //bottom BR eighth:
                // g.save();
                // g.scale(0.5, 0.5);
                // g.translate(1024*2-30,2*1024/aspect-30);
                // g.rotate(-Math.PI/2);
                // g.scale(-1,-1);
                // g.stroke(borderString);
                // g.restore();


                //this.stampLogo(g, aspect);
                ormG.fillStyle = "rgb(0, 50,255)";
                //this.stampLogo(ormG, aspect);

                bumpG.fillStyle = "white";
                //this.stampLogo(bumpG, aspect);

                var title = this.filename || "Your book title is loading ";
                var titleLines = title.split(" ").reduce((o, e) => {
                    var widthWithNext = g.measureText(o[o.length - 1] + " " + e).width;
                    if (widthWithNext > 900) {
                        o.push(e);
                    } else
                        o[o.length - 1] = o[o.length - 1] + " " + e
                    return o;
                }, [[""]]);
                // debugger;
                var w = g.measureText(title).width;





                ormG.fillStyle = "rgb(0, 50,255)";
                ormG.font = "700 80px Libre Baskerville";



                bumpG.shadowColor = "rgba(255,255,255,1)";
                bumpG.shadowBlur = 3;
                var shadowOffset = 2000;
                bumpG.shadowOffsetX = 0;
                bumpG.shadowOffsetY = shadowOffset * aspect;
                bumpG.fillStyle = "black";
                bumpG.font = "700 80px Libre Baskerville";

                titleLines.forEach((line, i, a) => {

                    var w = g.measureText(line).width;
                    ormG.fillText(line, 512 - w / 2, 512 / aspect + (i - a.length / 2) * 100);
                    g.fillText(line, 512 - w / 2, 512 / aspect + (i - a.length / 2) * 100);
                    bumpG.fillText(line, 512 - w / 2, 512 / aspect + (i - a.length / 2) * 100 - shadowOffset);
                });
                ormG.font = g.font = bumpG.font = "40px Libre Baskerville";
                var w = g.measureText(this.author || "Anonymous").width;
                ormG.fillText(this.author, 512 - w / 2, 512 / aspect + (titleLines.length / 2) * 100 - 40);
                g.fillText(this.author, 512 - w / 2, 512 / aspect + (titleLines.length / 2) * 100 - 40);

                bumpG.fillText(this.author, 512 - w / 2, 512 / aspect + (titleLines.length / 2) * 100 - 40 - shadowOffset);

                g.strokeStyle = gold;
                g.lineWidth = 5;
                ormG.strokeStyle = "rgb(0, 50,255)";
                ormG.lineWidth = 5;
                bumpG.strokeStyle = "rgba(255,255,255,1)";
                bumpG.lineWidth = 5;
                for (var i = 1; i < 4; i++) {




                }

                const tex = canvas => {
                    const t = new THREE.CanvasTexture(canvas);
                    t.wrapS = t.wrapT = THREE.RepeatWrapping;
                    t.rotation = Math.PI / 2;
                    return t;
                }
                window.cover = {
                    map: tex(c),
                    metalnessMap: tex(ormC),
                    normalMap: tex(this.bumpToNormal(bumpC, 1, 0.5))
                };
            }



            return window.cover;
        }

        buildPages(currentOffset)
        {
            while (this.pagePivot.children.length > 0)
                this.pagePivot.remove(this.pagePivot.children[0]);


            const bottomClickPivot = this.bottomClickPivot = new THREE.Mesh(new THREE.TorusGeometry(115, 5, 16, 100), new THREE.ShaderMaterial({
                fragmentShader: `

        uniform float hovered;
        uniform vec2 resolution;
        uniform vec2 pointerLocation;

        void main() {
          vec2 aspect = vec2(1., resolution.x/resolution.y);
          float dist = length(((pointerLocation/2. + 0.5 )- gl_FragCoord.xy/resolution.xy)/aspect);
          vec4 hoveredColor = vec4(1.0, hovered, 0.0, 1.0);
          vec4 transparent = vec4(0.,0.,0.,0.);
          gl_FragColor = mix(hoveredColor, transparent, smoothstep(0.0, 0.05, dist));
        }


        `
















                ,
                transparent: true,
                blending: THREE.AdditiveBlending,
                uniforms: {
                    hovered: {
                        value: 0
                    },
                    pointerLocation: {
                        value: new THREE.Vector2()
                    },
                    resolution: {
                        value: new THREE.Vector2()
                    }

                }

            }));
            const bottomDragPlane = this.bottomDragPlane = new THREE.Mesh(new THREE.CircleGeometry(145, 32), new THREE.MeshBasicMaterial({
                color: 'pink',
                side: THREE.DoubleSide
            }));
            bottomDragPlane.visible = false;
            // bottomClickPivot.visible = false;
            bottomDragPlane.rotation.x = Math.PI / 2;
            bottomDragPlane.rotation.y -= Math.PI / 2;
            bottomDragPlane.position.x = -90;

            this.pagePivot.add(bottomClickPivot);
            this.pagePivot.add(bottomDragPlane);
            bottomClickPivot.rotation.y = Math.PI / 2;
            bottomClickPivot.rotation.z = Math.PI / 2;
            bottomClickPivot.position.x = -90;
            bottomClickPivot.onBeforeRender = () => {

                if (this.pointerDown) {

                    bottomClickPivot.material.uniforms.pointerLocation.value.copy(this.dotScreen);
                } else {
                    bottomClickPivot.material.uniforms.pointerLocation.value.copy(this.pointer);

                }
                bottomClickPivot.material.uniforms.hovered.value = this.pointerDown ? 1 : 0;
                bottomClickPivot.material.uniforms.resolution.value.set(innerWidth, innerHeight).multiplyScalar(devicePixelRatio);

            };
            var currentOffset = Math.max(0.001, this.curPage / this.options.pageCount);
            var remainder = 1 - currentOffset;

            var totalWidth = this.options.pageCount / 10;
            var remainder = 1 - currentOffset;


            this.left = this.addPage(totalWidth * currentOffset, -totalWidth * currentOffset * 0.5);
            this.right = this.addPage(totalWidth * remainder, totalWidth * remainder * 0.5);
            this.center = this.addPage(0.01, 0);
            this.center.receiveShadow = false;
            const pageParts = this.coverPage();
            this.left.leftPage.map = pageParts.map;
            this.left.leftPage.metalness = this.left.leftPage.roughness = 1;
            this.left.leftPage.metalnessMap = this.left.leftPage.roughnessMap = pageParts.metalnessMap;
            this.left.leftPage.normalMap = pageParts.normalMap;

            this.left.curve = -1;
            this.right.curve = 1;
            this.center.curve = this.centerCurve;
            this.center.turnCurve = this.centerTurnCurve;
            this.left.onBeforeRender();
            this.right.onBeforeRender();
            this.center.onBeforeRender();

            this.pagePivot.add(this.left);
            this.pagePivot.add(this.right);
            this.pagePivot.add(this.center);



            this.right.position.y = this.center.position.y = this.left.position.y = 57;
            this.right.position.z = this.center.position.z = this.left.position.z = (currentOffset - 0.5) * totalWidth;
        }

        setPagesFrom(startPos, direction, left, center, right)
        {


            left.rightPage.map = this.pageTexture(startPos, 0);
            center.leftPage.map = this.pageTexture(startPos + 1, 1);
            center.rightPage.map = this.pageTexture(startPos + 2, 0);
            right.leftPage.map = this.pageTexture(startPos + 3, 1);


        }


        addShelf()
        {
            var o = {
                thickness: 0.026,
                height: 1.6,
                width: 0.92,
                depth: 0.33,
                shelfSpans: 5,
                cornerRadius: 0.0015
            };

            const normalMap = this.getWoodTexture();
            const shelfMaterial = new THREE.MeshStandardMaterial({
                color: 0x100802,
                roughness: 1,
                roughnessMap: this.noiseMap(),
                normalMap
            });
            var side = new THREE.Mesh(new RoundBox(o.thickness, o.depth, o.height + o.thickness, o.cornerRadius), shelfMaterial);
            side.rotation.x = Math.PI / 2;
            var shelfPivot = new THREE.Object3D();
            shelfPivot.add(side);
            side.position.x = o.width / 2 + o.thickness / 2;
            side = side.clone();
            side.position.x *= -1;
            shelfPivot.add(side);
            var basePlank = new THREE.Mesh(new RoundBox(o.width, o.thickness, o.depth, o.cornerRadius), shelfMaterial);
            for (var i = 0; i <= o.shelfSpans; i++) {
                var plank = basePlank.clone();
                shelfPivot.add(plank);
                plank.material = plank.material.clone();
                plank.material.roughnessMap = this.noiseMap();
                plank.material.normalMap = this.getWoodTexture();
                plank.position.y = (i / o.shelfSpans - 0.5) * o.height;
            }
            shelfPivot.position.y = o.height / 2;
            this.scene.add(shelfPivot);
        }


        noiseMap()
        {
            const c = document.createElement('canvas');
            c.width = c.height = 1024;
            const g = c.getContext('2d');
            g.fillStyle = "gray";
            g.fillRect(0, 0, 1024, 1024);
            g.globalAlpha = 0.3;
            for (var i = 0; i < 1e4; i++) {
                g.fillStyle = `hsl(0, 100%, ${Math.floor(Math.random() * 10 + 70)}%)`;
                g.fillRect(Math.random() * 1024, Math.random() * 1024, 50,20);

            }

            return new THREE.CanvasTexture(c);
        }


        bumpToNormal(canvas, offset=1, intensity=1)
        {
            const g = canvas.getContext('2d');
            const src = g.getImageData(0, 0, canvas.width, canvas.height);
            const dest = g.getImageData(0, 0, canvas.width, canvas.height);


            for (var i = 0; i < src.data.length; i += 4) {

                //TODO this doesn't resolve over the width boundary!
                var red = (src.data[i + 0] - src.data[i + 4 * offset]) * intensity;
                var green = (src.data[i + 0] - src.data[i + 4 * offset * canvas.width]) * intensity;
                var blue = 255 - Math.abs(red) - Math.abs(green);

                dest.data[i + 0] = 128 + red;
                dest.data[i + 1] = 128 + green;
                dest.data[i + 2] = blue;
                dest.data[i + 3] = 255;
            }

            g.putImageData(dest, 0, 0);
            return canvas;
        }



        getWoodMap(hue=0)
        {
            const c = document.createElement('canvas');
            c.width = c.height = 1024;
            const g = c.getContext('2d');
            c.style.outline = "2px solid blue";
            const grad = g.createLinearGradient(0, 0, 0, 1024);
            for (var i = 0; i < 50; i++) {

                grad.addColorStop(Math.random(), `hsl(${hue}, 100%, ${Math.floor(Math.random() * 100)}%)`);
            }
            g.fillStyle = grad;
            g.fillRect(0, 0, 1024, 1024);
            return c;
        }



        getWoodTexture()
        {
            var c1 = this.getWoodMap(0);

            var c2 = this.getWoodMap(0);
            var c3 = document.createElement('canvas');
            c3.width = c3.height = 1024;


            const g3 = c3.getContext('2d');
            const grad = g3.createLinearGradient(0, 0, 1024, 0);
            grad.addColorStop(0, "transparent");
            grad.addColorStop(0.5, "white");
            grad.addColorStop(1, "transparent");
            g3.fillStyle = grad;
            g3.fillRect(0, 0, 1024, 1024);
            g3.globalCompositeOperation = "xor";
            g3.drawImage(c2, 0, 0);
            const g1 = c1.getContext('2d');
            g1.drawImage(c3, 0, 0);
            return new THREE.CanvasTexture(this.bumpToNormal(c1, 1, 1));
        }

        addPage(thickness, xOffset=0)
        {

            thickness = Math.max(0.01, thickness);
            const segmentHeight = 6;
            const segmentCount = 20;
            const height = segmentHeight * segmentCount;
            const halfHeight = height * 0.5;

            const sizing = {
                segmentHeight: segmentHeight,
                segmentCount: segmentCount,
                height: height,
                thickness,
                xOffset,
                halfHeight: halfHeight
            };
            const geometry = this.createGeometry(sizing);
            const bones = this.createBones(sizing);
            const mesh = this.createMesh(geometry, bones);


            mesh.curve = 0;
            mesh.turnCurve = 0;
            mesh.onBeforeRender = () => {
                var sT = Math.sin(Date.now() / 10000);
                var amt = 0.8 * sT;
                bones.forEach((b, i) => {

                    var distToEarlyCurve = Math.abs(i - this.options.earlyPivot);
                    var earlyCurveContribution = smoothstep(this.options.earlyThreshold, 0, distToEarlyCurve);

                    var distToLateCurve = Math.abs(i - this.options.latePivot);
                    var lateCurveContribution = smoothstep(this.options.lateThreshold, 0, distToLateCurve);


                    var distToLateCurve = Math.abs(i - this.options.curlPivot);
                    var curlCurveContribution = smoothstep(this.options.curlThreshold, 0, distToLateCurve);

                    var spineCurveContribution = smoothstep(7, 1, i);

                    b.rotation.x = this.options.earlyIntensity / 20 * earlyCurveContribution * mesh.curve * this.options.openness
                        - this.options.lateIntensity / 20 * lateCurveContribution * mesh.curve * this.options.openness
                        + this.options.turnCurveIntensity / 20 * curlCurveContribution * mesh.turnCurve * this.options.openness;
                    b.rotation.y = -Math.sign(this.options.turnSpeed) * (0.15 * b.rotation.x * mesh.turnCurve * curlCurveContribution);
                    b.rotation.x += this.options.spineCurveIntensity * spineCurveContribution * this.options.openness;
                });
            };
            mesh.leftPage = mesh.material[5];
            mesh.rightPage = mesh.material[4];
            return mesh;
        }

        pageTexture(pageNumber, side) {
            const index = pageNumber;
            if (this.pageTextures && this.pageTextures[index]) {
                const tex = this.pageTextures[index];
                tex.center = new THREE.Vector2(0.5, 0.5);
                tex.rotation = Math.PI / 2;
                return tex;
            } else {
                const canvas = document.createElement('canvas');
                canvas.width = canvas.height = 1024;
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = 'black';
                ctx.fillRect(0, 0, 1024, 1024);
                return new THREE.CanvasTexture(canvas);
            }
        }



        bookGrid(angle=0)
        {

            if (this.pagesGrid == null) {
                const c = document.createElement('canvas');
                c.width = c.height = 1024;
                const g = c.getContext('2d');
                g.fillStyle = "gray";
                g.fillRect(0, 0, 1024, 1024);
                g.globalAlpha = 1;
                for (var i = 0; i < 1e2; i++) {
                    g.fillStyle = `hsl(0, 10%, ${Math.floor(Math.random() * 10 + 70)}%)`;
                    g.fillRect(0, Math.random() * 1024, 1024, 15);

                }
                this.pagesGrid = c;
            }
            const t = new THREE.CanvasTexture(this.pagesGrid);

            t.rotation = angle;
            t.wrapS = t.wrapT = THREE.RepeatWrapping;
            return t
        }

        blankTexture()
        {
            const c = document.createElement('canvas');
            const g = c.getContext('2d');
            c.width = c.height = 4;
            g.fillStyle = this.options.coverColor;
            g.fillRect(0, 0, 4, 4);
            return new THREE.CanvasTexture(c);
        }

        createMesh(geometry, bones)
        {

            var bgX = new THREE.MeshStandardMaterial({
                map: this.bookGrid()
            });
            var bgNY = new THREE.MeshStandardMaterial({
                map: this.bookGrid(-Math.PI / 2)
            });
            var red = new THREE.MeshStandardMaterial({
                color: this.options.coverColor
            });
            var bgY = new THREE.MeshStandardMaterial({
                map: this.bookGrid(Math.PI / 2)
            });
            const materials = [bgNY, bgY, bgX, red];
            for (var i = 0; i < 2; i++) {
                const material = new THREE.MeshStandardMaterial({
                    map: this.blankTexture(),
                    roughness: 0.5,
                    metalness: 0
                });
                materials.push(material);

            }


            const mesh = new THREE.SkinnedMesh(geometry, materials);
            const skeleton = new THREE.Skeleton(bones);

            mesh.add(bones[0]);

            mesh.bind(skeleton);

            mesh.castShadow = true;
            mesh.receiveShadow = true;
            // // const skeletonHelper = new THREE.SkeletonHelper( mesh );
            // skeletonHelper.material.linewidth = 2;

            return mesh;
        }
        createBones(sizing)
        {

            const bones = [];

            let prevBone = new THREE.Bone();
            bones.push(prevBone);
            prevBone.position.y = -sizing.halfHeight;

            for (let i = 0; i < sizing.segmentCount; i++) {

                const bone = new THREE.Bone();
                bone.position.y = sizing.segmentHeight;
                bones.push(bone);
                prevBone.add(bone);
                prevBone = bone;

            }

            return bones;

        }
        createGeometry(sizing)
        {

            const geometry = new THREE.BoxGeometry(10 * this.options.bookHeight, sizing.height, sizing.thickness, 2, sizing.segmentCount * 5);
            // const geometry = new THREE.PlaneGeometry(180,sizing.height,2,sizing.segmentCount*5);

            for (var n = 0; n < geometry.attributes.position.array.length; n += 3) {
                geometry.attributes.position.array[n + 2] += sizing.xOffset;
            }
            const position = geometry.attributes.position;

            const vertex = new THREE.Vector3();

            const skinIndices = [];
            const skinWeights = [];

            for (let i = 0; i < position.count; i++) {

                vertex.fromBufferAttribute(position, i);

                const y = (vertex.y + sizing.halfHeight);

                const skinIndex = Math.floor(y / sizing.segmentHeight);
                const skinWeight = (y % sizing.segmentHeight) / sizing.segmentHeight;

                skinIndices.push(skinIndex, skinIndex + 1, 0, 0);
                skinWeights.push(1 - skinWeight, skinWeight, 0, 0);

            }

            geometry.setAttribute('skinIndex', new THREE.Uint16BufferAttribute(skinIndices, 4));
            geometry.setAttribute('skinWeight', new THREE.Float32BufferAttribute(skinWeights, 4));

            return geometry;

        }

        exportBook()
        {
            const exporter = new GLTFExporter();
            exporter.parse(this.scene, data => {
                const blob = new Blob([data], {
                    type: 'application/octet-stream'
                });
                const a = Object.assign(document.createElement('a'), {
                    download: 'model.glb',
                    href: URL.createObjectURL(blob)
                });
                a.click();
            }, {
                binary: true
            });

        }
        initRenderer()
        {
            this.renderer = new THREE.WebGLRenderer({
                antialias: true
            });
            this.renderer.setSize(innerWidth, innerHeight);
            this.renderer.setClearColor(0x202020);
            this.renderer.setAnimationLoop(e => this.update(e));
            this.renderer.setPixelRatio(devicePixelRatio);
            this.renderer.xr.enabled = true;
            Object.assign(this.renderer.domElement.style, {
                position: 'fixed',
                top: 0,
                left: 0,

            });

            this.renderer.domElement.addEventListener('dragover', e => {
                e.preventDefault();
            });
            this.renderer.domElement.addEventListener('dragenter', e => {
                e.preventDefault();

            });
            this.renderer.domElement.addEventListener('dragleave', e => {
                e.preventDefault();

            });
            this.renderer.domElement.addEventListener('drop', e => {
                e.preventDefault();
                if (e.dataTransfer.files.length) {
                    const fR = new FileReader();
                    fR.addEventListener('load', loadEvt => this.processFile(loadEvt));
                    fR.readAsText(e.dataTransfer.files[0]);
                }
            });

            document.body.appendChild(this.renderer.domElement);
        }


        initVR()
        {
            const controllerModelFactory = new XRControllerModelFactory();
            const handModelFactory = new XRHandModelFactory().setPath("https://threejs.org/examples/models/fbx/");

            const addControls = number => {
                const controller = this.renderer.xr.getController(number);
                this.scene.add(controller);
                const grip = this.renderer.xr.getControllerGrip(number);
                grip.add(controllerModelFactory.createControllerModel(grip));
                this.scene.add(grip);
                const hand = this.renderer.xr.getHand(number);

                hand.add(handModelFactory.createHandModel(hand));

                this.scene.add(hand);
                return {
                    controller,
                    grip,
                    hand
                };
            };
            this.zero = addControls(0);
            this.one = addControls(1);
            //this.vrButton = VRButton.createButton(this.renderer);
            //document.body.appendChild(this.vrButton);
        }

        update(e)
        {
            this.controls.update();
            this.updatePointer();
            this.renderer.render(this.scene, this.camera);
        }

        initHDR()
        {
            this.renderer.physicallyCorrectLights = true;
            this.renderer.toneMapping = THREE.LinearToneMapping;
            this.renderer.outputEncoding = THREE.sRGBEncoding;
            this.renderer.toneMappingExposure = 0.3;
            this.renderer.shadowMap.enabled = true;


            const light = new THREE.DirectionalLight(0xdfebff, 1.75);
            light.position.set(0, 2, 1);

            light.castShadow = true;
            light.shadow.mapSize.width = 512;
            light.shadow.mapSize.height = 512;
            light.shadow.camera.left = -0.13;
            light.shadow.camera.right = 0.13;
            light.shadow.camera.top = 0.2;
            light.shadow.camera.bottom = -0.2;

            light.shadow.camera.near = .8;
            light.shadow.camera.far = 1.2;
            this.scene.add(light);
            // this.scene.add( new THREE.CameraHelper( light.shadow.camera ) );

            new RGBELoader()
                .setDataType(THREE.HalfFloatType)
                .setPath('https://threejs.org/examples/textures/equirectangular/')
                .load('royal_esplanade_1k.hdr', texture => {
                    const pmremGenerator = new THREE.PMREMGenerator(this.renderer);
                    pmremGenerator.compileEquirectangularShader();
                    const envMap = pmremGenerator.fromEquirectangular(texture).texture;
                    this.scene.environment = envMap;
                    texture.dispose();
                    pmremGenerator.dispose();
                });
        }
    }

    class RoundBox extends THREE.BufferGeometry {

        constructor(width=1, height=1, depth=1, radius=1, spans=5)
        {

            super();
            this.root = new THREE.Object3D();

            this.width = width;
            this.height = height;
            this.depth = depth;
            this.radius = radius;
            this.spans = spans;
            var xyz = [(this.width / 2 - this.radius), (this.height / 2 - this.radius), (this.depth / 2 - this.radius)];

            var plane = this._plane(0, 1, xyz);
            plane.position.set(0, 0, this.depth / 2);

            plane = this._plane(0, 1, xyz);
            plane.position.set(0, 0, -this.depth / 2);
            plane.rotation.x = Math.PI;

            plane = this._plane(2, 1, xyz);
            plane.position.set(this.width / 2, 0, 0);
            plane.rotation.y = Math.PI / 2;

            plane = this._plane(2, 1, xyz);
            plane.position.set(-this.width / 2, 0, 0);
            plane.rotation.y = -Math.PI / 2;

            plane = this._plane(0, 2, xyz);
            plane.position.set(0, (this.height / 2), 0);
            plane.rotation.x = -Math.PI / 2;

            plane = this._plane(0, 2, xyz);
            plane.position.set(0, (-this.height / 2), 0);
            plane.rotation.x = Math.PI / 2;

            var coefsA = [[1, 0, 1], [1, 0, -1], [-1, 0, -1], [-1, 0, 1]];
            var coefsB = [[0, 1, 1], [0, 1, -1], [0, -1, -1], [0, -1, 1]];
            var coefsC = [[1, -1, 0], [1, 1, 0], [-1, 1, 0], [-1, -1, 0]];

            for (var i = 0; i < coefsA.length; i++) {
                var cyl = this._cyl(this.height, i);
                this._setPos(cyl, coefsA[i], xyz);

                cyl = this._cyl(this.width, i);
                this._setPos(cyl, coefsB[i], xyz);
                cyl.rotation.z = Math.PI / 2;

                cyl = this._cyl(this.depth, i);
                this._setPos(cyl, coefsC[i], xyz);
                cyl.rotation.x = Math.PI / 2;
            }

            coefsA = [[-1, -1, 1], [1, -1, 1], [1, -1, -1], [-1, -1, -1]];
            coefsB = [[-1, 1, 1], [1, 1, 1], [1, 1, -1], [-1, 1, -1]];
            for (var i = 0; i < coefsA.length; i++) {
                var spCorner = this._spCorner(i, 1);
                this._setPos(spCorner, coefsA[i], xyz);
                spCorner = this._spCorner(i);
                this._setPos(spCorner, coefsB[i], xyz);
            }

            let geo = new Geometry();
            this.root.traverse(e => {
                if (e.geometry) {
                    e.geometry = new Geometry().fromBufferGeometry(e.geometry);
                    geo.mergeMesh(e);
                }
            });
            this.copy(geo.toBufferGeometry());
        }

        _plane(xi, yi, xyz)
        {
            var m = new THREE.Mesh(new THREE.PlaneGeometry(2 * xyz[xi], 2 * xyz[yi]));
            this.root.add(m);
            return m;
        }

        _setPos(mesh, coefs, xyz)
        {
            mesh.position.set(coefs[0] * xyz[0], coefs[1] * xyz[1], coefs[2] * xyz[2]);
        }

        _spCorner(i, j)
        {
            var m = new THREE.Mesh(new THREE.SphereGeometry(this.radius, this.spans, this.spans,
                i * Math.PI / 2, Math.PI / 2,
                (j || 0) * Math.PI / 2, Math.PI / 2
            ));
            this.root.add(m);
            return m;

        }

        _cyl(l, i)
        {
            var m = new THREE.Mesh(new THREE.CylinderGeometry(
                this.radius, this.radius, l - 2 * this.radius, this.spans,
                1, true, i * Math.PI / 2, Math.PI / 2));
            this.root.add(m);
            return m;
        }
        ;

    }


    document.fonts.ready.then(function() {
        window.app = new App();
    });
</script>
</html>
